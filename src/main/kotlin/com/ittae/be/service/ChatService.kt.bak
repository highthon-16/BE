package com.ittae.be.service

import com.fasterxml.jackson.databind.ObjectMapper
import com.ittae.be.client.*
import com.ittae.be.dto.*
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import reactor.core.publisher.Mono
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*

@Service
class ChatService(
    private val geminiClient: GeminiClient,
    private val mcpServerClient: McpServerClient,
    private val objectMapper: ObjectMapper
) {

    private val logger = LoggerFactory.getLogger(ChatService::class.java)

    fun processChat(request: ChatRequest, userId: Long): Mono<ChatResponse> {
        val sessionId = request.sessionId ?: generateSessionId()
        
        return try {
            val contextualPrompt = buildContextualPrompt(request.message, userId)
            
            geminiClient.generateContentWithCalendarTools(contextualPrompt)
                .flatMap { geminiResponse ->
                    handleGeminiResponse(geminiResponse, sessionId, userId)
                }
        } catch (e: Exception) {
            logger.error("Error in processChat", e)
            Mono.just(createErrorResponse(sessionId, "ì±„íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."))
        }
    }

    private fun buildContextualPrompt(userMessage: String, userId: Long): String {
        return """
            ë‹¹ì‹ ì€ ì‚¬ìš©ìì˜ ìº˜ë¦°ë”ë¥¼ ê´€ë¦¬í•˜ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤.
            ì‚¬ìš©ì ID: $userId
            í˜„ì¬ ì‹œê°„: ${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}
            
            ì‚¬ìš©ì ìš”ì²­: $userMessage
            
            ìº˜ë¦°ë” ì´ë²¤íŠ¸ ê´€ë ¨ ì‘ì—…ì„ ìˆ˜í–‰í•  ë•Œ:
            1. ì‹œê°„ì€ ISO 8601 í˜•ì‹(YYYY-MM-DDTHH:mm:ss)ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤
            2. ì¹´í…Œê³ ë¦¬ëŠ” STUDY, WORK, REST, ACTIVITY ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤
            3. ì§€ì† ì‹œê°„ì€ ë¶„ ë‹¨ìœ„ë¡œ ì§€ì •í•©ë‹ˆë‹¤
            4. ì‚¬ìš©ìì˜ ìš”ì²­ì„ ì •í™•íˆ íŒŒì•…í•˜ì—¬ ì ì ˆí•œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤
            
            ì‚¬ìš©ìì˜ ìš”ì²­ì„ ë¶„ì„í•˜ê³  í•„ìš”í•œ ê²½ìš° ìº˜ë¦°ë” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‘ì—…ì„ ìˆ˜í–‰í•˜ì„¸ìš”.
            ì‘ì—… ê²°ê³¼ëŠ” ì¹œê·¼í•˜ê³  ëª…í™•í•œ í•œêµ­ì–´ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”.
        """.trimIndent()
    }

    private fun handleGeminiResponse(
        geminiResponse: GeminiResponse, 
        sessionId: String, 
        userId: Long
    ): Mono<ChatResponse> {
        
        if (geminiResponse.error != null) {
            logger.error("Gemini API error: ${geminiResponse.error}")
            return Mono.just(createErrorResponse(sessionId, "AI ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${geminiResponse.error.message}"))
        }
        
        if (geminiResponse.candidates.isNullOrEmpty()) {
            return Mono.just(createErrorResponse(sessionId, "AI ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."))
        }
        
        val candidate = geminiResponse.candidates.first()
        val content = candidate.content
        
        if (content?.parts?.any { it.functionCall != null } == true) {
            val functionCall = content.parts.first { it.functionCall != null }.functionCall!!
            return handleMcpFunction(functionCall, sessionId, userId)
        } else {
            val responseText = content?.parts?.firstOrNull()?.text ?: "ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            return Mono.just(createTextResponse(sessionId, responseText))
        }
    }

    private fun handleMcpFunction(
        functionCall: FunctionCall, 
        sessionId: String, 
        userId: Long
    ): Mono<ChatResponse> {
        
        logger.info("Executing MCP function: ${functionCall.name} with args: ${functionCall.args}")
        
        return mcpServerClient.callMcpFunction(functionCall.name, functionCall.args)
            .flatMap { mcpResponse ->
                processMcpResponse(mcpResponse, functionCall, sessionId)
            }
    }
    
    private fun processMcpResponse(
        mcpResponse: McpResponse,
        functionCall: FunctionCall,
        sessionId: String
    ): Mono<ChatResponse> {
        if (mcpResponse.error != null) {
            logger.error("MCP function error: ${mcpResponse.error}")
            return Mono.just(createErrorResponse(sessionId, "ìº˜ë¦°ë” ì‘ì—… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${mcpResponse.error.message}"))
        }
        
        val actionInfo = ActionInfo(
            actionType = functionCall.name.uppercase(),
            result = mcpResponse.result,
            success = true
        )
        
        val responseMessage = generateSuccessMessage(functionCall.name, mcpResponse.result)
        
        val response = ChatResponse(
            message = responseMessage,
            sessionId = sessionId,
            actionPerformed = actionInfo,
            timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
        )
        
        return Mono.just(response)
    }

    private fun generateSuccessMessage(functionName: String, result: Any?): String {
        return when (functionName) {
            "create_calendar_event" -> "ìƒˆë¡œìš´ ì¼ì •ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤! âœ…"
            "update_calendar_event" -> "ì¼ì •ì´ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤! âœï¸"
            "delete_calendar_event" -> "ì¼ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ—‘ï¸"
            "get_all_events" -> {
                val events = if (result is List<*>) result else emptyList()
                "í˜„ì¬ ë“±ë¡ëœ ì¼ì •ì´ ${events.size}ê°œ ìˆìŠµë‹ˆë‹¤. ğŸ“…"
            }
            "get_events_by_date" -> {
                val events = if (result is List<*>) result else emptyList()
                "í•´ë‹¹ ë‚ ì§œì— ${events.size}ê°œì˜ ì¼ì •ì´ ìˆìŠµë‹ˆë‹¤. ğŸ“…"
            }
            "complete_event" -> "ì¼ì •ì´ ì™„ë£Œë¡œ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰"
            else -> "ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!"
        }
    }

    private fun createTextResponse(sessionId: String, text: String): ChatResponse {
        return ChatResponse(
            message = text,
            sessionId = sessionId,
            actionPerformed = null,
            timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
        )
    }

    private fun createErrorResponse(sessionId: String, errorMessage: String): ChatResponse {
        return ChatResponse(
            message = errorMessage,
            sessionId = sessionId,
            actionPerformed = ActionInfo(
                actionType = "ERROR",
                result = null,
                success = false
            ),
            timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
        )
    }

    private fun generateSessionId(): String {
        return "chat-${UUID.randomUUID().toString().substring(0, 8)}"
    }
}
